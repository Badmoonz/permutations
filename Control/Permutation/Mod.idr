module Control.Permutation.Mod

import Data.List
import Data.Vect
import Control.Permutation.Types

%default total

%access public export

||| This is essentially a group action. Given a permutation, we apply it to a vector.
sigma : Permutation n -> Vect n a -> Vect n a
sigma [] [] = []
sigma (p::ps) (x::xs) = insert (sigma ps xs) p
  where
    insert : Vect n a -> Fin (S n) -> Vect (S n) a
    insert l FZ = x::l
    insert [] _ = [x]
    insert (e::es) (FS k) = e :: insert es k

toVector : Permutation n -> Vect n (Fin n)
toVector {n} p = sigma p (sequential n)
  where
    sequential : (n : Nat) -> Vect n (Fin n)
    sequential Z = []
    sequential (S k) = FZ :: map FS (sequential k)

private
natToFin : (n : Nat) -> Fin (S n)
natToFin Z = FZ
natToFin (S k) = FS k' where k' = natToFin k

private
finiteL : (n : Nat) -> Vect (S n) (Fin (S n))
finiteL Z = FZ :: Nil
finiteL n@(S m) = natToFin n :: (map weaken $ finiteL m)

||| Returns all permutations of a certain order.
export
enumerate : (n : Nat) -> List (Permutation (S n))
enumerate Z = ((FZ :: Nil) :: Nil)
enumerate n@(S m) = (::) <$> (toList $ finiteL n) <*> (enumerate m)

||| 
fixNat : Permutation n -> Fin n -> Fin n
fixNat p n = index n $ (Delay $ toVector p)
  where
    index : Fin l-> Lazy (Vect l e) -> e
    index FZ     (x::xs) = x
    index (FS k) (x::xs) = index k xs

||| Orbit generated by a given element.
orbit : Permutation (S n) -> Fin (S n) -> Stream (Fin (S n))
orbit p {n} i = i :: go i where
  go : Fin (S n) -> Stream (Fin (S n))
  go j = next :: go next where
    next : Fin (S n)
    next = fixNat p j

||| Return the orbit of some permutation.
finOrbit : Permutation (S n) -> Fin (S n) -> List (Fin (S n))
finOrbit p {n} i = nub $ take n (orbit p i)

||| Return a list of disjoint cycles given a permutation
export
cycles : Permutation (S n) -> List (List (Fin (S n)))
cycles p {n} = nub . map sort . map (finOrbit p) . enumFromTo 0 $ (natToFin n)

private
getSwapsHelp : (List (Fin (S n)) -> List (Fin (S n), Fin (S n))) -> Permutation (S n) -> List (Fin (S n), Fin (S n))
getSwapsHelp f p = (>>= f) $ cycles p

||| Decompose a permutation into a product of swaps.
export
decompose : Permutation (S n) -> List (Fin (S n), Fin (S n))
decompose = getSwapsHelp overlappingPairs
  where
    overlappingPairs [] = []
    overlappingPairs [x] = []
    overlappingPairs (x::xs@(y::_))= (x, y) :: overlappingPairs xs

mutual

  even : Nat -> Bool
  even Z = True
  even (S k) = odd k

  odd : Nat -> Bool
  odd Z = False
  odd (S k) = even k

export
isEven : Permutation (S n) -> Bool
isEven = even . length . decompose

implementation Show (Permutation (S n)) where
  show {n} p = concatMap (go n) (cycles p)
    where
      go : (Show a) => Nat -> List a -> String
      go _ l@(_::_::_) = if n <= 9
        then "(" ++ concatMap show l ++ ")"
        else "(" ++ concatMap ((++ ",") . show) l ++ ")"
      go _ _ = ""

reverse : Permutation n
reverse {n=Z} = []
reverse {n=S _} = last :: reverse

||| E.g. (1234) for S_4
cycle : Permutation n
cycle {n=Z} = []
cycle {n=S _} = FZ :: cycle

private
fill : Fin n -> Permutation n
fill FZ = id
fill (FS k) = FS (zeros k) :: fill k
  where zeros : Fin m -> Fin m
        zeros FZ = FZ
        zeros (FS _) = FZ

private
injects : Permutation m -> Permutation n -> Bool
injects {m} {n} _ _ = m < n

||| The permutation Ï€_ij
export
pi : Fin n -> Fin n -> Permutation n
pi (FS j) (FS k) = FZ :: pi j k
pi (FS j) FZ = FS j :: fill j
pi FZ (FS k) = FS k :: fill k
pi FZ FZ = id
