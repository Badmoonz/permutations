module Control.Permutation.Mod

import Data.List
import Data.Vect
import Control.Permutation.Types

%default total

%access public export

private
natToFin : (n : Nat) -> Fin (S n)
natToFin Z = FZ
natToFin (S k) = FS k' where k' = natToFin k

private
finiteL : (n : Nat) -> Vect (S n) (Fin (S n))
finiteL Z = FZ :: Nil
finiteL n@(S m) = natToFin n :: (map weaken $ finiteL m)

||| Returns all permutations of a certain order.
export
enumerate : (n : Nat) -> List (Permutation (S n))
enumerate Z = ((FZ :: Nil) :: Nil)
enumerate n@(S m) = (::) <$> (toList $ finiteL n) <*> (enumerate m)

||| Show where an integer is sent.
fixNat : Permutation n -> Fin n -> Fin n
fixNat p n = index n $ (Delay $ toVector p)
  where
    index : Fin l-> Lazy (Vect l e) -> e
    index FZ     (x::xs) = x
    index (FS k) (x::xs) = index k xs

||| Orbit generated by a given element.
orbit : Permutation (S n) -> Fin (S n) -> Stream (Fin (S n))
orbit p {n} i = i :: go i where
  go : Fin (S n) -> Stream (Fin (S n))
  go j = next :: go next where
    next : Fin (S n)
    next = fixNat p j

||| Return the orbit of some permutation.
finOrbit : Permutation (S n) -> Fin (S n) -> List (Fin (S n))
finOrbit p {n} i = nub $ take n (orbit p i)

||| Return a list of disjoint cycles given a permutation
export
cycles : Permutation (S n) -> List (List (Fin (S n)))
cycles p {n} = nub . map sort . map (finOrbit p) . enumFromTo 0 $ (natToFin n)

implementation Show (Permutation (S n)) where
  show {n} p = concatMap (go n) (cycles p)
    where
      go : (Show a) => Nat -> List a -> String
      go _ l@(_::_::_) = if n <= 9
        then "(" ++ concatMap show l ++ ")"
        else "(" ++ concatMap ((++ ",") . show) l ++ ")"
      go _ _ = ""

||| swaps a permutation into a product of swaps.
export
swaps : Permutation (S n) -> List (Fin (S n), Fin (S n))
swaps = go overlappingPairs
  where
    go : (List (Fin (S n)) -> List (Fin (S n), Fin (S n))) -> Permutation (S n) -> List (Fin (S n), Fin (S n))
    go f p = (>>= f) $ cycles p
    overlappingPairs [] = []
    overlappingPairs [x] = []
    overlappingPairs (x::xs@(y::_))= (x, y) :: overlappingPairs xs

mutual
  private
  even : Nat -> Bool
  even Z = True
  even (S k) = odd k

  private
  odd : Nat -> Bool
  odd Z = False
  odd (S k) = even k

export
isEven : Permutation (S n) -> Bool
isEven = even . length . swaps

||| Permutation that reverses a vector completely
reverse : Permutation n
reverse {n=Z} = []
reverse {n=S _} = last :: reverse

||| Shift everything over by one, e.g. (1234) for S_4
cycle : Permutation n
cycle {n=Z} = []
cycle {n=S _} = FZ :: cycle

private
fill : Fin n -> Permutation n
fill FZ = id
fill (FS k) = FS (zeros k) :: fill k
  where zeros : Fin m -> Fin m
        zeros FZ = FZ
        zeros (FS _) = FZ

inject : (LTE m n) -> Permutation m -> Permutation n
inject {m} {n} = ?hole

||| The permutation Ï€_ij
export
pi : Fin n -> Fin n -> Permutation n
pi (FS j) (FS k) = FZ :: pi j k
pi (FS j) FZ = FS j :: fill j
pi FZ (FS k) = FS k :: fill k
pi FZ FZ = id
