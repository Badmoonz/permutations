!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
arityVect	Control/Permutation/Arity.idr	/^arityVect : (Vect n Type) -> (b : Type) -> Type$/;"	f
big	Test/Spec.idr	/^        big : Permutation 11$/;"	c
compose	Control/Permutation/Types.idr	/^compose : Permutation n -> Permutation n -> Permutation n$/;"	f
cycle	Control/Permutation/Mod.idr	/^cycle : Permutation n$/;"	c
cycles	Control/Permutation/Mod.idr	/^cycles : Permutation (S n) -> List (List (Fin (S n)))$/;"	f
enumerate	Control/Permutation/Mod.idr	/^enumerate : (n : Nat) -> List (Permutation (S n))$/;"	f
even	Control/Permutation/Mod.idr	/^  even : Nat -> Bool$/;"	f
fill	Control/Permutation/Mod.idr	/^fill : Fin n -> Permutation n$/;"	f
finOrbit	Control/Permutation/Mod.idr	/^finOrbit : Permutation (S n) -> Fin (S n) -> List (Fin (S n))$/;"	f
finiteL	Control/Permutation/Mod.idr	/^finiteL : (n : Nat) -> Vect (S n) (Fin (S n))$/;"	f
fixNat	Control/Permutation/Mod.idr	/^fixNat : Permutation n -> Fin n -> Fin n$/;"	f
fuckInputs	Control/Permutation/Arity.idr	/^fuckInputs : (p : Permutation 3) -> arityVect [a, b, c] d -> arityVect (sigma p [a, b, c]) d$/;"	f
go	Control/Permutation/Mod.idr	/^      go : (Show a) => Nat -> List a -> String$/;"	f
go	Control/Permutation/Mod.idr	/^    go : (List (Fin (S n)) -> List (Fin (S n), Fin (S n))) -> Permutation (S n) -> List (Fin (S n), Fin (S n))$/;"	f
go	Control/Permutation/Mod.idr	/^  go : Fin (S n) -> Stream (Fin (S n))$/;"	f
id	Control/Permutation/Types.idr	/^id : Permutation n$/;"	c
index	Control/Permutation/Mod.idr	/^    index : Fin l-> Lazy (Vect l e) -> e$/;"	f
inject	Control/Permutation/Mod.idr	/^inject : (LTE m n) -> Permutation m -> Permutation n$/;"	f
insert	Control/Permutation/Mod.idr	/^    insert : Vect n a -> Fin (S n) -> Vect (S n) a$/;"	f
inverse	Control/Permutation/Types.idr	/^  inverse : t -> t$/;"	f
invert	Control/Permutation/Types.idr	/^invert : Permutation n -> Permutation n$/;"	f
isEven	Control/Permutation/Mod.idr	/^isEven : Permutation (S n) -> Bool$/;"	f
natToFin	Control/Permutation/Mod.idr	/^natToFin : (n : Nat) -> Fin (S n)$/;"	f
next	Control/Permutation/Mod.idr	/^    next : Fin (S n)$/;"	c
odd	Control/Permutation/Mod.idr	/^  odd : Nat -> Bool$/;"	f
orbit	Control/Permutation/Mod.idr	/^orbit : Permutation (S n) -> Fin (S n) -> Stream (Fin (S n))$/;"	f
pi	Control/Permutation/Mod.idr	/^pi : Fin n -> Fin n -> Permutation n$/;"	f
prf	Control/Permutation/Arity.idr	/^prf : (p : Permutation 3) -> (Int -> Int -> Int -> Bool) = arityVect (sigma p [Int, Int, Int]) Bool$/;"	f
reverse	Control/Permutation/Mod.idr	/^reverse : Permutation n$/;"	c
sequential	Control/Permutation/Mod.idr	/^    sequential : (n : Nat) -> Vect n (Fin n)$/;"	f
sigma	Control/Permutation/Mod.idr	/^sigma : Permutation n -> Vect n a -> Vect n a$/;"	f
specSuite	Test/Spec.idr	/^specSuite : IO ()$/;"	c
swap1	Test/Spec.idr	/^        swap1 : (Fin 4, Fin 4)$/;"	c
swap2	Test/Spec.idr	/^        swap2 : (Fin 4, Fin 4)$/;"	c
swaps	Control/Permutation/Mod.idr	/^swaps : Permutation (S n) -> List (Fin (S n), Fin (S n))$/;"	f
toVector	Control/Permutation/Mod.idr	/^toVector : Permutation n -> Vect n (Fin n)$/;"	f
